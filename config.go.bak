package cmd

import (
	"errors"
	"fmt"

	"github.com/mitchellh/mapstructure"
	"github.com/spf13/cobra"
	"github.com/spf13/viper"
)

var configCmd = &cobra.Command{
	Use:   "config",
	Short: "Configure ghub.",
	Args: func(cmd *cobra.Command, args []string) error {
		if len(args) < 1 {
			return errors.New("Action must be given. (create-profile, select-profile, current-profile, set, get)")
		}
		if err := cobra.OnlyValidArgs(cmd, args[:1]); err != nil {
			return errors.New("Action must be one of " + fmt.Sprint(cmd.ValidArgs))
		}
		action := args[0]
		if err := validations[action](cmd, args); err != nil {
			return err
		}
		return nil
	},
	Run: func(cmd *cobra.Command, args []string) {
		actions[args[0]](cmd, args)
	},
	ValidArgs: []string{"create-profile", "select-profile", "current-profile", "set", "get"},
}

func init() {
	rootCmd.AddCommand(configCmd)
	configCmd.AddCommand(createProfileCmd)
	configCmd.AddCommand(selectProfileCmd)
	configCmd.AddCommand(currentProfileCmd)
	configCmd.AddCommand(setCmd)
	configCmd.AddCommand(getCmd)
	configCmd.Flags().String("token", "", "Personal Access Token")
	configCmd.MarkFlagRequired("token")

	configCmd.Flags().StringP("api-endpoint", "e", "https://api.github.com", "The REST API Endpoint. Typically the enpoint for a GitHub Enterprise app is 'https://[github_enterprise_url]/api/v3'.")
	configCmd.Flags().String("name", "", "Name of the profile")
	configCmd.Flags().String("userid", "", "Login User ID")
}

var validations = map[string](func(cmd *cobra.Command, args []string) error){
	"create-profile": func(cmd *cobra.Command, args []string) error {
		name, token, userid := cmd.Flags().Lookup("name").Value.String(), cmd.Flags().Lookup("token").Value.String(), cmd.Flags().Lookup("userid").Value.String()
		if token == "" {
			return errors.New("Personal Access Token must be given with --token.")
		}
		fmt.Println(token)
		if name != "" {
			fmt.Println(name)
		}
		if userid != "" {
			fmt.Println(userid)
		}
		return errors.New("sadf")
	},
	"select-profile": func(cmd *cobra.Command, args []string) error {
		if len(args) != 2 {
			return errors.New("profile name must be given for action create-profile.")
		}
		return nil
	},
	"current-profile": func(cmd *cobra.Command, args []string) error {
		if len(args) != 1 {
			return errors.New("create-profile action takes no arguments.")
		}
		return nil
	},
	"set": func(cmd *cobra.Command, args []string) error {
		return nil
	},
	"get": func(cmd *cobra.Command, args []string) error {
		return nil
	},
}

var actions = map[string](func(cmd *cobra.Command, args []string)){
	"create-profile": func(cmd *cobra.Command, args []string) {
		fmt.Println("inside createProfile")
	},
	"select-profile": func(cmd *cobra.Command, args []string) {
		givenProfileName := args[1]

		profiles, err := getProfiles()
		if err != nil {
			fmt.Println(err)
			return
		}

		matchesGivenProfileName := func(profile Profile) bool { return profile.Name == givenProfileName }
		if profilePtr := findProfile(profiles, matchesGivenProfileName); profilePtr == nil {
			fmt.Println(fmt.Sprintf("No profile by the name %s exists.", givenProfileName))
		} else {
			viper.Set("selectedProfile", profilePtr.Name)
			viper.WriteConfig()
			fmt.Println(fmt.Sprintf("Using profile %s.", profilePtr.Name))
		}
	},
	"current-profile": func(cmd *cobra.Command, args []string) {
		if selectedProfile := viper.Get("selectedProfile"); selectedProfile == nil {
			fmt.Println("No profile is selected yet.")
		} else {
			fmt.Println(selectedProfile)
		}
	},
	"set": func(cmd *cobra.Command, args []string) {
		fmt.Println("inside set()")

	},
	"get": func(cmd *cobra.Command, args []string) {
		fmt.Println("inside get()")
	},
}

type Profile struct {
	Name   string
	Userid string
	Token  string
}

func findProfile(profiles []Profile, predicate func(Profile) bool) *Profile {
	for _, p := range profiles {
		if predicate(p) {
			return &p
		}
	}
	return nil
}

func getProfiles() ([]Profile, error) {
	rawProfiles := viper.Get("profiles")

	var profiles []Profile
	err := mapstructure.Decode(rawProfiles, &profiles)
	if err != nil {
		return nil, err
	}

	for i, profile := range profiles {
		if profile.Userid == "" {
			return nil, errors.New(fmt.Sprintf("profile[%d].userid is empty.", i+1))
		}
		if profile.Token == "" {
			return nil, errors.New(fmt.Sprintf("profile[%d].token is empty.", i+1))
		}
	}
	return profiles, nil
}
